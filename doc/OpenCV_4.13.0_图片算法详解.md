# OpenCV 4.13.0 图片算法详解

## 目录

1. [图像滤波算法](#1-图像滤波算法)
2. [形态学操作](#2-形态学操作)
3. [边缘检测算法](#3-边缘检测算法)
4. [几何变换](#4-几何变换)
5. [阈值处理](#5-阈值处理)
6. [直方图处理](#6-直方图处理)
7. [轮廓检测与分析](#7-轮廓检测与分析)
8. [特征检测](#8-特征检测)
9. [图像分割](#9-图像分割)
10. [颜色空间转换](#10-颜色空间转换)
11. [模板匹配](#11-模板匹配)
12. [霍夫变换](#12-霍夫变换)
13. [距离变换](#13-距离变换)
14. [图像金字塔](#14-图像金字塔)

---

## 1. 图像滤波算法

### 1.1 高斯滤波 (Gaussian Blur)

**函数**: `cv::GaussianBlur()`

**原理**: 
高斯滤波是一种线性平滑滤波，使用高斯函数作为卷积核。高斯函数的形式为：
$$G(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}$$

滤波过程是对图像进行加权平均，权重由高斯函数决定，距离中心越近的像素权重越大。

**作用**:
- 去除图像中的高斯噪声
- 平滑图像，减少细节
- 降低图像分辨率（下采样前预处理）

**使用场景**:
- **图像预处理，去除噪声**: 在图像分析前去除高斯噪声，提高后续处理质量。常用于医学图像、卫星图像等需要降噪的场景
- **边缘检测前的平滑处理**: 在 Canny、Sobel 等边缘检测算法前使用，减少噪声对边缘检测的干扰。典型流程：高斯滤波 → Canny 边缘检测
- **图像降采样前的抗锯齿处理**: 在图像缩放前进行高斯滤波，避免出现锯齿效应。常用于图像缩略图生成、多尺度图像处理
- **人脸识别、目标检测等任务的前处理**: 在深度学习模型输入前进行预处理，统一图像质量。YOLO、SSD 等目标检测模型常用
- **实时视频处理**: 对视频帧进行快速平滑，减少帧间抖动。适用于监控视频、实时流处理
- **参数选择建议**: 
  - 轻微平滑：Size(3,3), sigma=0.8
  - 中等平滑：Size(5,5), sigma=1.5
  - 强平滑：Size(9,9), sigma=2.5

**代码示例**:
```cpp
cv::Mat src, dst;
cv::GaussianBlur(src, dst, cv::Size(5, 5), 0);
```

---

### 1.2 中值滤波 (Median Blur)

**函数**: `cv::medianBlur()`

**原理**: 
中值滤波是一种非线性滤波方法。对于每个像素，将其邻域内所有像素值排序，取中位数作为该像素的新值。这种方法能有效去除椒盐噪声，同时保持边缘信息。

**作用**:
- 去除椒盐噪声（脉冲噪声）
- 保持边缘信息，不会使边缘模糊
- 去除孤立噪声点

**使用场景**:
- **去除扫描图像中的噪声点**: 扫描文档时产生的黑白噪声点，中值滤波能有效去除而不影响文字清晰度。常用于 OCR 预处理
- **医学图像处理**: CT、MRI 等医学图像中的脉冲噪声去除，保持重要细节。在保持边缘的同时去除噪声
- **去除图像中的斑点噪声**: 老照片修复、历史图像处理中常见的斑点噪声。适用于照片修复、档案数字化
- **实时视频处理中的噪声去除**: 监控摄像头、网络视频中的随机噪声点。计算速度快，适合实时处理
- **保护边缘的去噪**: 需要保持边缘清晰度的场景，如工业检测、质量检测中的图像预处理
- **参数选择建议**:
  - 小噪声点：ksize=3
  - 中等噪声：ksize=5
  - 大噪声点：ksize=7（注意：ksize 必须是奇数）
- **注意事项**: 对高斯噪声效果不如高斯滤波，但对椒盐噪声效果更好

**代码示例**:
```cpp
cv::Mat src, dst;
cv::medianBlur(src, dst, 5);  // 5x5 邻域
```

---

### 1.3 双边滤波 (Bilateral Filter)

**函数**: `cv::bilateralFilter()`

**原理**: 
双边滤波结合了空间邻近度和像素值相似度。它同时考虑：
1. 空间距离：距离中心越近的像素权重越大
2. 像素值相似度：与中心像素值越相似的像素权重越大

公式：$$BF[I]_p = \frac{1}{W_p}\sum_{q \in S}G_{\sigma_s}(||p-q||)G_{\sigma_r}(|I_p-I_q|)I_q$$

**作用**:
- 平滑图像同时保持边缘清晰
- 去除噪声而不模糊边缘
- 实现类似美颜的效果

**使用场景**:
- **图像去噪同时保持边缘**: 需要平滑图像但保持重要边缘的场景，如医学图像分析、工业检测。比高斯滤波更好地保持边缘
- **图像美颜处理**: 手机美颜相机、视频通话美颜功能。平滑皮肤纹理同时保持五官轮廓清晰
- **细节增强**: 在保持整体平滑的同时突出细节。适用于艺术照片处理、图像增强
- **实时视频处理**: 视频会议、直播中的实时美颜和降噪。虽然计算较慢，但效果优于简单滤波
- **高动态范围图像处理**: HDR 图像合成前的预处理，保持细节的同时减少噪声
- **参数选择建议**:
  - 轻微平滑：d=5, sigmaColor=50, sigmaSpace=50
  - 中等平滑：d=9, sigmaColor=75, sigmaSpace=75
  - 强平滑（美颜）：d=15, sigmaColor=100, sigmaSpace=100
- **注意事项**: 计算时间较长，不适合对速度要求极高的实时应用

**代码示例**:
```cpp
cv::Mat src, dst;
cv::bilateralFilter(src, dst, 9, 75, 75);
```

---

### 1.4 均值滤波 (Box Filter / Blur)

**函数**: `cv::blur()`, `cv::boxFilter()`

**原理**: 
均值滤波是最简单的线性滤波，将邻域内所有像素值的平均值作为输出。卷积核所有元素值相等（通常为1），然后归一化。

**作用**:
- 简单快速的图像平滑
- 去除均匀噪声
- 降低图像细节

**使用场景**:
- **快速图像平滑**: 对速度要求高但精度要求不高的场景，如实时预览、快速预览生成
- **简单的噪声去除**: 均匀分布的轻微噪声去除。适用于简单的图像预处理流程
- **图像预处理**: 作为更复杂算法的预处理步骤，快速降低图像细节复杂度
- **移动设备图像处理**: 计算资源有限的移动设备上，需要快速平滑的场景
- **参数选择建议**:
  - 轻微平滑：Size(3,3)
  - 中等平滑：Size(5,5)
  - 强平滑：Size(9,9)
- **注意事项**: 会使边缘模糊，不适合需要保持边缘的场景

**代码示例**:
```cpp
cv::Mat src, dst;
cv::blur(src, dst, cv::Size(5, 5));
```

---

### 1.5 自定义滤波 (Filter2D)

**函数**: `cv::filter2D()`

**原理**: 
使用自定义的卷积核（kernel）对图像进行卷积操作。可以用于实现各种线性滤波效果，如锐化、边缘增强等。

**作用**:
- 实现自定义的线性滤波效果
- 图像锐化
- 边缘增强
- 特征提取

**使用场景**:
- **自定义图像处理算法**: 实现特定的图像处理效果，如自定义边缘检测、纹理增强等。研究新算法时的基础工具
- **图像锐化**: 使用锐化核（如拉普拉斯核）增强图像细节。适用于照片后期处理、图像增强
- **特定特征的提取**: 设计专门的卷积核提取特定特征，如方向边缘、特定纹理模式。用于特征工程
- **研究新的滤波算法**: 算法研究和原型开发，快速验证新的滤波思路
- **图像增强**: 通过自定义核实现对比度增强、细节增强等效果
- **卷积核示例**:
  - 锐化核：[[0,-1,0],[-1,5,-1],[0,-1,0]]
  - 边缘检测：[[-1,-1,-1],[-1,8,-1],[-1,-1,-1]]
  - 浮雕效果：[[-2,-1,0],[-1,1,1],[0,1,2]]
- **注意事项**: 需要理解卷积原理，合理设计卷积核才能达到预期效果

**代码示例**:
```cpp
cv::Mat kernel = (cv::Mat_<float>(3,3) << 
    0, -1, 0,
    -1, 5, -1,
    0, -1, 0);
cv::Mat src, dst;
cv::filter2D(src, dst, -1, kernel);
```

---

## 2. 形态学操作

### 2.1 腐蚀 (Erosion)

**函数**: `cv::erode()`

**原理**: 
腐蚀操作使用结构元素（structuring element）扫描图像，输出像素值是结构元素覆盖区域内的最小值。对于二值图像，会使白色区域缩小，黑色区域扩大。

**作用**:
- 去除小的白色噪声点
- 分离连接的对象
- 缩小对象尺寸
- 消除细小的突起

**使用场景**:
- **二值图像处理**: OCR 中分离粘连字符、去除小的噪声点。常用于文档图像处理、文字识别预处理
- **去除小的噪声点**: 二值化后的小白点、小噪点去除。工业检测、质量检测中的常见需求
- **分离粘连的字符或对象**: 通过腐蚀缩小对象，分离轻微粘连的字符或物体。车牌识别、字符分割常用
- **图像分割预处理**: 在分割前清理图像，去除小的干扰区域。医学图像分割、细胞分割常用
- **形态学细化**: 作为形态学操作的基础，用于骨架提取、线条细化等
- **参数选择建议**:
  - 小对象去除：3x3 矩形核，1次迭代
  - 中等对象：5x5 椭圆核，2-3次迭代
  - 大对象：7x7 椭圆核，多次迭代
- **注意事项**: 会缩小对象尺寸，可能需要后续膨胀操作恢复

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
cv::erode(src, dst, kernel);
```

---

### 2.2 膨胀 (Dilation)

**函数**: `cv::dilate()`

**原理**: 
膨胀操作使用结构元素扫描图像，输出像素值是结构元素覆盖区域内的最大值。对于二值图像，会使白色区域扩大，黑色区域缩小。

**作用**:
- 填充对象内部的小孔
- 连接断开的对象
- 扩大对象尺寸
- 填充边缘凹陷

**使用场景**:
- **填充对象内部空洞**: 二值图像中对象内部的小孔填充。OCR 中填充字符内部空洞、医学图像中填充区域空洞
- **连接断开的线条**: 连接因噪声或阈值处理而断开的线条。文档分析、电路板检测中连接断线
- **扩大检测到的区域**: 目标检测后扩大检测框，包含更多上下文。ROI 扩展、区域增长算法
- **图像修复**: 修复图像中的小缺陷、填补小洞。老照片修复、图像修复应用
- **形态学操作基础**: 作为形态学操作的基础，用于闭运算、形态学梯度等
- **参数选择建议**:
  - 小空洞填充：3x3 矩形核，1次迭代
  - 中等空洞：5x5 椭圆核，2-3次迭代
  - 大空洞：7x7 椭圆核，多次迭代
- **注意事项**: 会扩大对象尺寸，可能连接本应分离的对象

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
cv::dilate(src, dst, kernel);
```

---

### 2.3 开运算 (Opening)

**函数**: `cv::morphologyEx()` with `MORPH_OPEN`

**原理**: 
开运算是先腐蚀后膨胀的组合操作：$Opening = Dilation(Erosion(image))$

**作用**:
- 去除小的白色噪声点
- 平滑对象轮廓
- 断开细小的连接
- 保持对象大小基本不变

**使用场景**:
- **去除小的噪声点**: 二值图像中的小噪点去除，同时保持对象大小。比单独腐蚀更好，因为不会缩小对象
- **平滑对象边界**: 去除对象边界上的小突起和凹陷。形状分析、轮廓提取前的预处理
- **分离粘连对象**: 轻微粘连的对象分离。细胞计数、颗粒分析中分离接触的对象
- **图像预处理**: 作为更复杂算法的预处理步骤，清理图像同时保持对象完整性
- **OCR 预处理**: 文档图像中去除小的噪声点，保持字符完整性。文字识别前的标准预处理
- **参数选择建议**:
  - 小噪声：3x3 核
  - 中等噪声：5x5 核
  - 大噪声：7x7 核
- **典型流程**: 开运算 → 闭运算，先去除噪声再填充空洞

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
cv::morphologyEx(src, dst, cv::MORPH_OPEN, kernel);
```

---

### 2.4 闭运算 (Closing)

**函数**: `cv::morphologyEx()` with `MORPH_CLOSE`

**原理**: 
闭运算是先膨胀后腐蚀的组合操作：$Closing = Erosion(Dilation(image))$

**作用**:
- 填充对象内部的小孔
- 连接断开的对象
- 平滑对象轮廓
- 保持对象大小基本不变

**使用场景**:
- **填充对象内部空洞**: 二值图像中对象内部的小孔填充，同时保持对象大小。比单独膨胀更好
- **连接断开的线条**: 连接因噪声断开的线条，同时保持线条粗细。文档分析、电路检测
- **平滑对象边界**: 填充边界凹陷，平滑边界。形状分析、轮廓提取
- **图像修复**: 修复图像中的小缺陷，填补小洞。老照片修复、图像修复
- **OCR 后处理**: 填充字符内部空洞，连接断开的笔画。提高 OCR 识别率
- **参数选择建议**:
  - 小空洞：3x3 核
  - 中等空洞：5x5 核
  - 大空洞：7x7 核
- **典型流程**: 闭运算 → 开运算，先填充空洞再去除噪声

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_ELLIPSE, cv::Size(5, 5));
cv::morphologyEx(src, dst, cv::MORPH_CLOSE, kernel);
```

---

### 2.5 形态学梯度 (Morphological Gradient)

**函数**: `cv::morphologyEx()` with `MORPH_GRADIENT`

**原理**: 
形态学梯度是膨胀和腐蚀的差值：$Gradient = Dilation(image) - Erosion(image)$

**作用**:
- 提取对象边界
- 突出边缘信息
- 检测对象轮廓

**使用场景**:
- **边缘检测**: 二值图像中的边缘提取，比传统边缘检测更适合处理二值图像。快速获取对象边界
- **轮廓提取**: 提取对象轮廓，用于后续的形状分析、轮廓匹配。比 Canny 更适合二值图像
- **对象边界分析**: 分析对象边界特性，如边界宽度、边界形状等。形状分析、特征提取
- **形态学边缘增强**: 突出对象边界，用于可视化、调试。图像处理流程中的中间步骤可视化
- **参数选择建议**:
  - 细边界：3x3 核
  - 中等边界：5x5 核
  - 粗边界：7x7 核
- **注意事项**: 只适用于二值图像，对灰度图像效果不佳

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(3, 3));
cv::morphologyEx(src, dst, cv::MORPH_GRADIENT, kernel);
```

---

### 2.6 顶帽运算 (Top Hat)

**函数**: `cv::morphologyEx()` with `MORPH_TOPHAT`

**原理**: 
顶帽运算是原图像与开运算结果的差值：$TopHat = image - Opening(image)$

**作用**:
- 提取比周围亮的区域
- 突出小的亮细节
- 背景校正

**使用场景**:
- **提取小的亮对象**: 从复杂背景中提取小的亮区域。工业检测中提取亮点、缺陷检测
- **背景不均匀的图像处理**: 处理光照不均匀的图像，提取前景对象。文档扫描、医学图像分析
- **细节增强**: 突出图像中的小细节，增强局部对比度。显微图像分析、细节提取
- **背景校正**: 去除缓慢变化的背景，突出前景。天文图像处理、科学图像分析
- **参数选择建议**:
  - 小对象：核大小应大于对象大小，如 9x9 或 15x15
  - 背景校正：核大小应大于背景变化尺度
- **典型应用**: 工业检测中的亮点检测、医学图像中的小病灶提取

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));
cv::morphologyEx(src, dst, cv::MORPH_TOPHAT, kernel);
```

---

### 2.7 黑帽运算 (Black Hat)

**函数**: `cv::morphologyEx()` with `MORPH_BLACKHAT`

**原理**: 
黑帽运算是闭运算结果与原图像的差值：$BlackHat = Closing(image) - image$

**作用**:
- 提取比周围暗的区域
- 突出小的暗细节
- 检测暗区域

**使用场景**:
- **提取小的暗对象**: 从亮背景中提取小的暗区域。缺陷检测、暗点检测
- **检测暗区域**: 检测图像中的暗区域、阴影区域。阴影检测、暗区分析
- **细节分析**: 分析图像中的暗细节。显微图像中的暗结构分析
- **缺陷检测**: 工业检测中检测暗缺陷、暗点。质量检测、表面缺陷检测
- **参数选择建议**:
  - 小对象：核大小应大于对象大小
  - 暗区域检测：根据暗区域大小选择核大小
- **典型应用**: 工业质量检测中的暗缺陷检测、医学图像中的暗区域分析

**代码示例**:
```cpp
cv::Mat src, dst, kernel;
kernel = cv::getStructuringElement(cv::MORPH_RECT, cv::Size(9, 9));
cv::morphologyEx(src, dst, cv::MORPH_BLACKHAT, kernel);
```

---

## 3. 边缘检测算法

### 3.1 Canny 边缘检测

**函数**: `cv::Canny()`

**原理**: 
Canny 边缘检测是一个多阶段的算法：
1. **高斯滤波**: 平滑图像，去除噪声
2. **计算梯度**: 使用 Sobel 算子计算图像梯度幅值和方向
3. **非极大值抑制**: 细化边缘，只保留局部最大值
4. **双阈值检测**: 使用高阈值和低阈值确定边缘
5. **边缘连接**: 通过滞后阈值连接边缘

**作用**:
- 检测图像中的边缘
- 提供精确的边缘定位
- 抑制噪声影响

**使用场景**:
- **图像边缘检测**: 高精度的边缘检测，广泛应用于计算机视觉。自动驾驶中的车道线检测、物体轮廓提取
- **轮廓提取**: 提取对象轮廓用于形状分析。OCR 中的文字轮廓提取、医学图像中的器官轮廓提取
- **特征提取**: 作为特征提取的预处理步骤。SIFT、SURF 等特征检测器的预处理
- **计算机视觉预处理**: 目标检测、图像分割等任务的标准预处理步骤。YOLO、Mask R-CNN 等模型的预处理
- **文档分析**: 文档图像中的文字边缘、表格线检测。OCR、文档理解系统
- **参数选择建议**:
  - 低阈值/高阈值比例：通常为 1:2 或 1:3，如 50/150 或 100/200
  - 噪声较多：提高阈值，如 100/200
  - 细节重要：降低阈值，如 30/90
- **典型流程**: 灰度化 → 高斯滤波 → Canny 边缘检测 → 形态学操作（可选）
- **注意事项**: 对噪声敏感，通常需要先进行高斯滤波

**代码示例**:
```cpp
cv::Mat src, edges;
cv::Canny(src, edges, 50, 150);
```

---

### 3.2 Sobel 算子

**函数**: `cv::Sobel()`

**原理**: 
Sobel 算子使用两个 3x3 卷积核分别计算水平和垂直方向的梯度：
- 水平方向: $G_x = \begin{bmatrix} -1 & 0 & 1 \\ -2 & 0 & 2 \\ -1 & 0 & 1 \end{bmatrix}$
- 垂直方向: $G_y = \begin{bmatrix} -1 & -2 & -1 \\ 0 & 0 & 0 \\ 1 & 2 & 1 \end{bmatrix}$

梯度幅值: $G = \sqrt{G_x^2 + G_y^2}$

**作用**:
- 计算图像梯度
- 检测边缘方向
- 提取边缘信息

**使用场景**:
- **边缘检测**: 快速边缘检测，计算水平和垂直方向的边缘。实时应用中的边缘检测
- **梯度计算**: 计算图像梯度用于光流、图像配准等。SLAM、视觉里程计中的梯度计算
- **方向信息提取**: 提取边缘方向信息用于特征描述。HOG 特征提取、方向梯度直方图
- **图像特征提取**: 作为特征提取的基础，计算图像梯度特征。深度学习中的梯度特征
- **图像锐化**: 通过梯度信息实现图像锐化。照片后期处理
- **参数选择建议**:
  - 边缘检测：ksize=3，计算 x 和 y 方向梯度后合并
  - 梯度计算：根据精度要求选择 ksize=3 或 5
- **典型应用**: HOG 特征提取、光流计算、图像配准

**代码示例**:
```cpp
cv::Mat src, grad_x, grad_y, abs_grad_x, abs_grad_y, grad;
cv::Sobel(src, grad_x, CV_16S, 1, 0, 3);
cv::Sobel(src, grad_y, CV_16S, 0, 1, 3);
cv::convertScaleAbs(grad_x, abs_grad_x);
cv::convertScaleAbs(grad_y, abs_grad_y);
cv::addWeighted(abs_grad_x, 0.5, abs_grad_y, 0.5, 0, grad);
```

---

### 3.3 Scharr 算子

**函数**: `cv::Scharr()`

**原理**: 
Scharr 算子是 Sobel 算子的改进版本，具有更好的旋转不变性。使用更大的卷积核来获得更精确的梯度估计。

**作用**:
- 更精确的梯度计算
- 更好的旋转不变性
- 边缘检测

**使用场景**:
- **需要高精度梯度的应用**: 对梯度精度要求高的应用，如高精度图像配准、精密测量
- **边缘检测**: 比 Sobel 更精确的边缘检测，旋转不变性更好。高质量边缘检测应用
- **方向信息提取**: 提取精确的方向信息用于特征描述。高精度特征提取
- **参数选择建议**: 固定使用 3x3 核，比 Sobel 3x3 更精确
- **典型应用**: 高精度图像配准、精密测量、高质量边缘检测

**代码示例**:
```cpp
cv::Mat src, grad_x, grad_y;
cv::Scharr(src, grad_x, CV_16S, 1, 0);
cv::Scharr(src, grad_y, CV_16S, 0, 1);
```

---

### 3.4 Laplacian 算子

**函数**: `cv::Laplacian()`

**原理**: 
Laplacian 算子是二阶微分算子，用于检测图像中的快速变化。它计算图像的二阶导数，对噪声敏感。

Laplacian 核: $\nabla^2 f = \frac{\partial^2 f}{\partial x^2} + \frac{\partial^2 f}{\partial y^2}$

**作用**:
- 检测边缘和角点
- 图像锐化
- 检测快速变化区域

**使用场景**:
- **边缘检测**: 二阶导数边缘检测，对边缘更敏感。快速边缘检测应用
- **图像锐化**: 通过拉普拉斯算子实现图像锐化。照片增强、细节增强
- **特征检测**: 检测图像中的快速变化区域，用于特征点检测。角点检测的辅助方法
- **医学图像处理**: 医学图像中的边缘增强、细节突出。X光片、CT 图像处理
- **参数选择建议**:
  - 边缘检测：ksize=3 或 5
  - 图像锐化：使用拉普拉斯核进行锐化
- **注意事项**: 对噪声非常敏感，通常需要先进行平滑处理

**代码示例**:
```cpp
cv::Mat src, dst;
cv::Laplacian(src, dst, CV_16S, 3);
cv::convertScaleAbs(dst, dst);
```

---

## 4. 几何变换

### 4.1 图像缩放 (Resize)

**函数**: `cv::resize()`

**原理**: 
图像缩放通过插值方法改变图像尺寸。常用的插值方法包括：
- **最近邻插值**: 速度快，但质量较低
- **双线性插值**: 平衡速度和质量
- **双三次插值**: 质量高，但速度慢
- **区域插值**: 适合缩小图像

**作用**:
- 改变图像尺寸
- 图像缩放
- 调整图像分辨率

**使用场景**:
- **图像预处理**: 深度学习模型输入前的尺寸调整。YOLO、ResNet 等模型需要固定输入尺寸
- **调整图像大小以适应模型输入**: 将不同尺寸的图像调整为模型要求的尺寸。CNN 模型的标准预处理
- **图像显示**: 将大图像缩小以适应显示窗口。图像查看器、图像浏览器
- **图像压缩**: 通过缩小图像尺寸减少存储空间。缩略图生成、图像压缩
- **多尺度处理**: 生成不同尺度的图像用于多尺度分析。图像金字塔构建、多尺度特征提取
- **插值方法选择**:
  - **INTER_NEAREST**: 最快，质量最低，适合实时预览
  - **INTER_LINEAR**: 平衡速度和质量，最常用
  - **INTER_CUBIC**: 高质量，适合放大图像
  - **INTER_AREA**: 适合缩小图像，避免锯齿
  - **INTER_LANCZOS4**: 最高质量，适合高质量图像处理
- **参数选择建议**:
  - 缩小图像：使用 INTER_AREA
  - 放大图像：使用 INTER_CUBIC 或 INTER_LANCZOS4
  - 实时应用：使用 INTER_LINEAR

**代码示例**:
```cpp
cv::Mat src, dst;
cv::resize(src, dst, cv::Size(640, 480), 0, 0, cv::INTER_LINEAR);
```

---

### 4.2 仿射变换 (Affine Transform)

**函数**: `cv::warpAffine()`, `cv::getAffineTransform()`

**原理**: 
仿射变换保持平行线的平行性，可以表示平移、旋转、缩放和剪切。变换矩阵为 2x3 矩阵：
$$\begin{bmatrix} x' \\ y' \\ 1 \end{bmatrix} = \begin{bmatrix} a_{11} & a_{12} & b_1 \\ a_{21} & a_{22} & b_2 \end{bmatrix} \begin{bmatrix} x \\ y \\ 1 \end{bmatrix}$$

**作用**:
- 图像旋转
- 图像平移
- 图像缩放
- 图像剪切

**使用场景**:
- **图像校正**: 校正倾斜、变形的图像。文档扫描校正、图像几何校正
- **图像配准**: 将多幅图像对齐到同一坐标系。图像拼接、多视角图像对齐
- **数据增强**: 深度学习中的数据增强，通过旋转、缩放、剪切增加训练数据多样性
- **图像变换**: 实现图像的旋转、平移、缩放、剪切等变换。图像编辑、图像处理
- **目标跟踪**: 跟踪目标时进行仿射变换校正。视频跟踪、目标跟踪
- **参数获取方法**:
  - 三点对应：使用 `getAffineTransform()` 从 3 对对应点计算
  - 手动构造：根据旋转角度、平移量等手动构造变换矩阵
- **典型应用**: 文档扫描校正、图像拼接、数据增强、目标跟踪

**代码示例**:
```cpp
cv::Mat src, dst, M;
cv::Point2f srcTri[3], dstTri[3];
// 设置变换点
M = cv::getAffineTransform(srcTri, dstTri);
cv::warpAffine(src, dst, M, src.size());
```

---

### 4.3 透视变换 (Perspective Transform)

**函数**: `cv::warpPerspective()`, `cv::getPerspectiveTransform()`

**原理**: 
透视变换可以表示更复杂的几何变换，包括透视效果。使用 3x3 齐次变换矩阵，可以表示任意四边形到四边形的映射。

**作用**:
- 图像透视校正
- 文档扫描校正
- 视角变换
- 图像配准

**使用场景**:
- **文档扫描**: 将倾斜拍摄的文档校正为正面视图。手机扫描应用、文档数字化
- **图像校正**: 校正透视变形，如从斜角度拍摄的图像校正为正视图。建筑摄影校正
- **视角变换**: 实现视角变换，如俯视图、侧视图转换。监控视频分析、视角转换
- **AR/VR 应用**: 增强现实和虚拟现实中的图像变换、视角对齐。AR 标记跟踪、VR 场景渲染
- **图像拼接**: 多幅图像的透视对齐和拼接。全景图像生成、图像拼接
- **参数获取方法**: 使用 `getPerspectiveTransform()` 从 4 对对应点计算变换矩阵
- **典型应用**: 文档扫描应用（如 CamScanner）、图像校正、AR 应用

**代码示例**:
```cpp
cv::Mat src, dst, M;
cv::Point2f srcPoints[4], dstPoints[4];
// 设置四个对应点
M = cv::getPerspectiveTransform(srcPoints, dstPoints);
cv::warpPerspective(src, dst, M, src.size());
```

---

### 4.4 图像旋转

**函数**: `cv::getRotationMatrix2D()`, `cv::warpAffine()`

**原理**: 
图像旋转是仿射变换的特例，通过旋转矩阵实现：
$$M = \begin{bmatrix} \cos\theta & -\sin\theta & (1-\cos\theta) \cdot center_x + \sin\theta \cdot center_y \\ \sin\theta & \cos\theta & -\sin\theta \cdot center_x + (1-\cos\theta) \cdot center_y \end{bmatrix}$$

**作用**:
- 旋转图像
- 图像校正
- 方向调整

**使用场景**:
- **图像方向校正**: 校正旋转的图像，如扫描文档、拍摄照片的方向校正。OCR 预处理
- **数据增强**: 深度学习训练中的数据增强，通过旋转增加数据多样性。图像分类、目标检测训练
- **图像预处理**: 图像分析前的方向标准化。统一图像方向便于后续处理
- **图像编辑**: 图像编辑软件中的旋转功能。照片编辑、图像处理
- **参数设置**:
  - 旋转中心：通常为图像中心 `Point2f(src.cols/2.0, src.rows/2.0)`
  - 旋转角度：正值为逆时针，负值为顺时针
  - 缩放因子：1.0 为不缩放
- **典型应用**: OCR 方向校正、数据增强、图像编辑

**代码示例**:
```cpp
cv::Mat src, dst, M;
cv::Point2f center(src.cols/2.0, src.rows/2.0);
M = cv::getRotationMatrix2D(center, 45, 1.0);
cv::warpAffine(src, dst, M, src.size());
```

---

## 5. 阈值处理

### 5.1 固定阈值 (Threshold)

**函数**: `cv::threshold()`

**原理**: 
固定阈值将像素值与阈值比较，根据比较结果将像素分为两类。支持多种阈值类型：
- **THRESH_BINARY**: $dst(x,y) = \begin{cases} maxval & if src(x,y) > thresh \\ 0 & otherwise \end{cases}$
- **THRESH_BINARY_INV**: 反向二值化
- **THRESH_TRUNC**: 截断
- **THRESH_TOZERO**: 零化
- **THRESH_TOZERO_INV**: 反向零化

**作用**:
- 图像二值化
- 分割前景和背景
- 简化图像处理

**使用场景**:
- **图像二值化**: 将灰度图像转换为二值图像，简化后续处理。文档图像处理、工业检测
- **目标分割**: 分割前景和背景，提取目标对象。目标检测、图像分割
- **OCR 预处理**: 文字识别前的二值化处理，提高识别率。文档 OCR、文字识别系统
- **边缘检测预处理**: 边缘检测前的二值化，简化边缘检测。轮廓提取、形状分析
- **阈值类型选择**:
  - **THRESH_BINARY**: 标准二值化，前景为白色
  - **THRESH_BINARY_INV**: 反向二值化，前景为黑色
  - **THRESH_TRUNC**: 截断，超过阈值的像素设为阈值
  - **THRESH_TOZERO**: 零化，低于阈值的像素设为 0
- **参数选择建议**:
  - 文档图像：阈值通常为 127-150
  - 高对比度图像：阈值可以较高，如 180-200
  - 低对比度图像：阈值较低，如 80-120
- **典型应用**: OCR 预处理、工业检测、目标分割

**代码示例**:
```cpp
cv::Mat src, dst;
cv::threshold(src, dst, 127, 255, cv::THRESH_BINARY);
```

---

### 5.2 Otsu 阈值

**函数**: `cv::threshold()` with `THRESH_OTSU`

**原理**: 
Otsu 方法自动选择最优阈值，使得类间方差最大。它假设图像由前景和背景两类组成，通过最大化类间方差来找到最佳分割点。

**作用**:
- 自动选择最优阈值
- 处理双峰直方图图像
- 自适应二值化

**使用场景**:
- **自动阈值选择**: 无需手动设置阈值，自动选择最优阈值。批量图像处理、自动化系统
- **双峰直方图图像处理**: 处理前景和背景明显分离的图像。文档扫描、印刷品图像
- **OCR 预处理**: 文字识别前的自动二值化，适应不同光照条件。文档 OCR 系统
- **医学图像分割**: 医学图像中的组织分割、病灶分割。CT、MRI 图像分析
- **工业检测**: 工业图像中的自动阈值分割。质量检测、缺陷检测
- **适用条件**: 图像直方图应具有明显的双峰特征（前景和背景分离明显）
- **参数设置**: 阈值参数设为 0，算法自动计算最优阈值
- **典型应用**: 批量文档处理、自动化 OCR、医学图像分析

**代码示例**:
```cpp
cv::Mat src, dst;
cv::threshold(src, dst, 0, 255, cv::THRESH_BINARY | cv::THRESH_OTSU);
```

---

### 5.3 Triangle 阈值

**函数**: `cv::threshold()` with `THRESH_TRIANGLE`

**原理**: 
Triangle 方法通过寻找直方图的最大值和最小值之间的直线距离最大的点来确定阈值。适用于单峰直方图。

**作用**:
- 自动阈值选择
- 处理单峰直方图
- 简单快速

**使用场景**:
- **单峰直方图图像**: 处理只有一个峰的直方图图像，如背景占主导的图像。某些特殊场景的图像处理
- **快速阈值选择**: 比 Otsu 更快的自动阈值选择方法。实时应用、快速处理
- **简单分割任务**: 简单的二值化任务，不需要高精度。快速原型开发
- **适用条件**: 图像直方图应为单峰分布
- **参数设置**: 阈值参数设为 0，算法自动计算
- **注意事项**: 适用范围较窄，不如 Otsu 方法通用

**代码示例**:
```cpp
cv::Mat src, dst;
cv::threshold(src, dst, 0, 255, cv::THRESH_BINARY | cv::THRESH_TRIANGLE);
```

---

### 5.4 自适应阈值 (Adaptive Threshold)

**函数**: `cv::adaptiveThreshold()`

**原理**: 
自适应阈值根据像素邻域的统计特性计算局部阈值。有两种方法：
- **ADAPTIVE_THRESH_MEAN_C**: 使用邻域均值
- **ADAPTIVE_THRESH_GAUSSIAN_C**: 使用加权均值（高斯权重）

**作用**:
- 处理光照不均匀的图像
- 局部自适应二值化
- 提高分割质量

**使用场景**:
- **光照不均匀的图像**: 处理光照变化明显的图像，每个区域使用不同的阈值。阴影下的文档、不均匀光照场景
- **文档扫描**: 扫描文档时由于光照不均匀导致的灰度变化。手机扫描应用、文档数字化
- **OCR 预处理**: 文字识别前处理光照不均匀的文档图像，提高识别率。移动 OCR 应用
- **复杂背景下的目标分割**: 背景复杂、光照变化的目标分割。工业检测、质量检测
- **方法选择**:
  - **ADAPTIVE_THRESH_MEAN_C**: 使用邻域均值，计算快，适合大多数场景
  - **ADAPTIVE_THRESH_GAUSSIAN_C**: 使用高斯加权均值，质量更好，适合高质量要求
- **参数选择建议**:
  - blockSize: 邻域大小，必须是奇数，通常为 11、15、21
  - C: 从均值或加权均值中减去的常数，通常为 2-10
- **典型应用**: 手机扫描应用、移动 OCR、工业检测

**代码示例**:
```cpp
cv::Mat src, dst;
cv::adaptiveThreshold(src, dst, 255, cv::ADAPTIVE_THRESH_GAUSSIAN_C, 
                      cv::THRESH_BINARY, 11, 2);
```

---

## 6. 直方图处理

### 6.1 直方图计算 (CalcHist)

**函数**: `cv::calcHist()`

**原理**: 
直方图统计图像中每个灰度级（或颜色通道）的像素数量。对于灰度图像，直方图是一维的；对于彩色图像，可以计算每个通道的直方图或联合直方图。

**作用**:
- 分析图像亮度分布
- 图像特征提取
- 图像质量评估
- 对比度分析

**使用场景**:
- **图像分析**: 分析图像的亮度分布、对比度特性。图像质量评估、图像特性分析
- **特征提取**: 提取直方图特征用于图像分类、检索。图像检索系统、图像分类
- **图像质量评估**: 通过直方图分析评估图像质量，如对比度、亮度分布。图像质量检测
- **图像匹配**: 通过比较直方图进行图像匹配、相似度计算。图像检索、重复图像检测
- **颜色分析**: 分析图像的颜色分布，用于颜色校正、颜色增强。图像处理、颜色分析
- **直方图类型**:
  - 灰度直方图：单通道，256 个 bin
  - 彩色直方图：多通道，可以计算联合直方图或分别计算
- **典型应用**: 图像检索系统、图像分类、颜色分析

**代码示例**:
```cpp
std::vector<cv::Mat> bgr_planes;
cv::split(src, bgr_planes);
int histSize = 256;
float range[] = {0, 256};
const float* histRange = {range};
cv::Mat b_hist, g_hist, r_hist;
cv::calcHist(&bgr_planes[0], 1, 0, cv::Mat(), b_hist, 1, &histSize, &histRange);
```

---

### 6.2 直方图均衡化 (EqualizeHist)

**函数**: `cv::equalizeHist()`

**原理**: 
直方图均衡化通过重新分布像素值来增强图像对比度。它将累积分布函数（CDF）映射到均匀分布，使得输出图像的直方图尽可能均匀。

变换函数: $s = T(r) = (L-1)\int_0^r p_r(w)dw$

**作用**:
- 增强图像对比度
- 改善图像视觉效果
- 标准化图像亮度

**使用场景**:
- **图像增强**: 增强低对比度图像的视觉效果，提高图像质量。照片增强、图像修复
- **低对比度图像处理**: 处理对比度低的图像，如雾天图像、低光照图像。图像增强应用
- **医学图像处理**: 增强医学图像的对比度，突出重要信息。X光片、CT 图像增强
- **图像预处理**: 作为图像分析的预处理步骤，标准化图像对比度。计算机视觉预处理
- **适用条件**: 适用于整体对比度低的图像，对局部对比度变化效果有限
- **注意事项**: 可能过度增强某些区域，导致细节丢失
- **典型应用**: 照片增强、医学图像处理、低光照图像增强

**代码示例**:
```cpp
cv::Mat src, dst;
cv::cvtColor(src, src, cv::COLOR_BGR2GRAY);
cv::equalizeHist(src, dst);
```

---

### 6.3 CLAHE (Contrast Limited Adaptive Histogram Equalization)

**函数**: `cv::createCLAHE()`

**原理**: 
CLAHE 是自适应直方图均衡化的改进版本，通过限制对比度来避免过度增强。它将图像分成多个小块，对每个块进行直方图均衡化，然后使用双线性插值合并结果。

**作用**:
- 局部对比度增强
- 避免过度增强
- 改善图像细节

**使用场景**:
- **医学图像处理**: 增强医学图像的局部对比度，突出细节。X光片、CT、MRI 图像处理
- **细节增强**: 增强图像中的细节，保持整体亮度平衡。高质量图像处理、照片增强
- **局部对比度改善**: 改善局部区域的对比度，避免整体过度增强。图像增强应用
- **高质量图像处理**: 需要高质量结果的图像处理应用。专业图像处理、科学图像分析
- **参数选择建议**:
  - clipLimit: 对比度限制，通常为 2.0-4.0，值越大对比度增强越强
  - tileGridSize: 分块大小，通常为 (8,8) 或 (16,16)，块越小局部适应性越好
- **优势**: 比全局直方图均衡化更好地保持图像自然外观，避免过度增强
- **典型应用**: 医学图像处理、高质量照片增强、科学图像分析

**代码示例**:
```cpp
cv::Mat src, dst;
cv::Ptr<cv::CLAHE> clahe = cv::createCLAHE(2.0, cv::Size(8, 8));
clahe->apply(src, dst);
```

---

### 6.4 直方图比较 (CompareHist)

**函数**: `cv::compareHist()`

**原理**: 
直方图比较计算两个直方图之间的相似度。支持多种比较方法：
- **CORREL**: 相关系数
- **CHISQR**: 卡方检验
- **INTERSECT**: 交集
- **BHATTACHARYYA**: Bhattacharyya 距离

**作用**:
- 图像相似度比较
- 图像匹配
- 目标识别
- 图像检索

**使用场景**:
- **图像检索**: 基于直方图相似度的图像检索系统。图像搜索引擎、相似图像查找
- **目标识别**: 通过直方图匹配识别目标对象。颜色特征匹配、目标识别
- **图像匹配**: 匹配不同图像中的相似区域。图像配准、图像对齐
- **相似度分析**: 分析图像之间的相似度，用于去重、分类等。重复图像检测、图像分类
- **比较方法选择**:
  - **HISTCMP_CORREL**: 相关系数，值越大越相似，范围 [0,1]
  - **HISTCMP_CHISQR**: 卡方检验，值越小越相似
  - **HISTCMP_INTERSECT**: 交集，值越大越相似
  - **HISTCMP_BHATTACHARYYA**: Bhattacharyya 距离，值越小越相似，范围 [0,1]
- **典型应用**: 图像检索系统、相似图像查找、目标识别

**代码示例**:
```cpp
cv::Mat hist1, hist2;
double similarity = cv::compareHist(hist1, hist2, cv::HISTCMP_CORREL);
```

---

### 6.5 反向投影 (Back Projection)

**函数**: `cv::calcBackProject()`

**原理**: 
反向投影使用模板图像的直方图，在目标图像中查找相似区域。对于目标图像的每个像素，使用其在直方图中的概率值替换原像素值。

**作用**:
- 目标跟踪
- 图像分割
- 区域查找
- 颜色匹配

**使用场景**:
- **目标跟踪**: 基于颜色的目标跟踪，使用目标颜色直方图在视频中跟踪目标。MeanShift、CamShift 跟踪算法
- **颜色分割**: 基于颜色直方图进行图像分割，提取特定颜色的区域。颜色分割、区域提取
- **区域检测**: 在图像中检测与模板直方图相似的区域。目标检测、区域查找
- **图像分割**: 基于直方图反向投影的图像分割。颜色分割、区域分割
- **工作原理**: 将直方图概率值映射回图像空间，高概率区域表示与模板相似
- **典型应用**: MeanShift 跟踪、颜色分割、目标检测

**代码示例**:
```cpp
cv::Mat hist, backproj;
cv::calcBackProject(&images, 1, channels, hist, backproj, &ranges);
```

---

## 7. 轮廓检测与分析

### 7.1 轮廓查找 (FindContours)

**函数**: `cv::findContours()`

**原理**: 
轮廓查找使用边缘跟踪算法（如 Suzuki-Abe 算法）在二值图像中查找轮廓。支持多种检索模式：
- **RETR_EXTERNAL**: 只检索外部轮廓
- **RETR_LIST**: 检索所有轮廓，无层次关系
- **RETR_CCOMP**: 检索所有轮廓，组织为两级层次
- **RETR_TREE**: 检索所有轮廓，重建完整层次

**作用**:
- 检测对象边界
- 提取对象轮廓
- 形状分析
- 对象分割

**使用场景**:
- **对象检测**: 在二值图像中检测对象轮廓，用于目标检测、对象定位。工业检测、质量检测
- **形状分析**: 提取对象轮廓进行形状分析、形状识别。形状识别、对象分类
- **图像分割**: 通过轮廓提取实现图像分割。医学图像分割、细胞分割
- **目标识别**: 提取目标轮廓用于识别和分类。OCR、目标识别系统
- **检索模式选择**:
  - **RETR_EXTERNAL**: 只检测外部轮廓，忽略内部孔洞。快速检测、简单场景
  - **RETR_LIST**: 检测所有轮廓，无层次关系。简单应用、快速处理
  - **RETR_CCOMP**: 两级层次，外部轮廓和内部孔洞。需要区分内外的情况
  - **RETR_TREE**: 完整层次结构，包含所有父子关系。复杂形状分析、需要层次信息
- **近似方法选择**:
  - **CHAIN_APPROX_NONE**: 存储所有点，精度最高但数据量大
  - **CHAIN_APPROX_SIMPLE**: 压缩水平、垂直、对角线，减少点数
- **典型应用**: 工业检测、OCR、医学图像分析、形状识别

**代码示例**:
```cpp
std::vector<std::vector<cv::Point>> contours;
std::vector<cv::Vec4i> hierarchy;
cv::findContours(binary, contours, hierarchy, cv::RETR_TREE, cv::CHAIN_APPROX_SIMPLE);
```

---

### 7.2 轮廓绘制 (DrawContours)

**函数**: `cv::drawContours()`

**原理**: 
在图像上绘制检测到的轮廓，可以绘制所有轮廓或指定索引的轮廓。

**作用**:
- 可视化轮廓
- 调试轮廓检测
- 结果展示

**使用场景**:
- **轮廓可视化**: 在图像上绘制检测到的轮廓，用于结果展示、调试。图像处理结果可视化
- **调试**: 调试轮廓检测算法，查看检测结果是否正确。算法开发、问题诊断
- **结果展示**: 在应用程序中展示轮廓检测结果。用户界面、结果展示
- **参数说明**:
  - contourIdx: 轮廓索引，-1 表示绘制所有轮廓
  - color: 轮廓颜色
  - thickness: 轮廓线宽，-1 表示填充
- **典型应用**: 图像处理工具、调试工具、结果可视化

**代码示例**:
```cpp
cv::Mat drawing = cv::Mat::zeros(binary.size(), CV_8UC3);
cv::drawContours(drawing, contours, -1, cv::Scalar(0, 255, 0), 2);
```

---

### 7.3 轮廓面积 (ContourArea)

**函数**: `cv::contourArea()`

**原理**: 
使用格林公式计算轮廓包围的面积。对于简单轮廓，使用 Shoelace 公式计算。

**作用**:
- 计算对象面积
- 过滤小轮廓
- 对象大小分析

**使用场景**:
- **对象大小分析**: 计算对象面积，用于大小分析、尺寸测量。工业检测、质量检测
- **轮廓过滤**: 根据面积过滤轮廓，去除小噪声、保留大对象。轮廓预处理、噪声去除
- **特征提取**: 面积作为形状特征用于分类、识别。形状特征提取、对象分类
- **典型应用**: 工业检测中的尺寸测量、OCR 中的字符过滤、医学图像中的区域分析

**代码示例**:
```cpp
double area = cv::contourArea(contour);
```

---

### 7.4 轮廓周长 (ArcLength)

**函数**: `cv::arcLength()`

**原理**: 
计算轮廓的周长，通过累加相邻轮廓点之间的欧氏距离。

**作用**:
- 计算轮廓长度
- 形状特征提取
- 对象分析

**使用场景**:
- **形状分析**: 周长作为形状特征用于形状分析、形状识别。形状特征提取
- **特征提取**: 周长与面积的比值（紧凑度）作为形状特征。形状描述、对象分类
- **对象测量**: 测量对象的周长，用于尺寸测量。工业测量、质量检测
- **典型应用**: 形状分析、对象测量、特征提取

**代码示例**:
```cpp
double perimeter = cv::arcLength(contour, true);
```

---

### 7.5 轮廓近似 (ApproxPolyDP)

**函数**: `cv::approxPolyDP()`

**原理**: 
使用 Douglas-Peucker 算法近似轮廓为更少的点。算法递归地找到距离原始曲线最远的点，如果距离小于阈值，则用直线段替换该段。

**作用**:
- 简化轮廓
- 减少轮廓点数
- 多边形近似

**使用场景**:
- **轮廓简化**: 减少轮廓点数，简化轮廓表示。减少存储空间、提高处理速度
- **形状识别**: 将轮廓近似为多边形，用于形状识别。矩形、三角形、多边形检测
- **多边形检测**: 检测图像中的多边形形状。工业检测、几何形状识别
- **几何形状分析**: 分析对象的几何形状特性。形状分析、几何特征提取
- **参数选择**: epsilon 通常为周长的 2%-5%，值越大简化越多
- **典型应用**: 形状识别、多边形检测、轮廓简化

**代码示例**:
```cpp
std::vector<cv::Point> approx;
double epsilon = 0.02 * cv::arcLength(contour, true);
cv::approxPolyDP(contour, approx, epsilon, true);
```

---

### 7.6 凸包 (ConvexHull)

**函数**: `cv::convexHull()`

**原理**: 
计算轮廓的凸包，使用 Graham 扫描算法或 QuickHull 算法。凸包是包含所有轮廓点的最小凸多边形。

**作用**:
- 计算凸包
- 形状分析
- 缺陷检测
- 形状简化

**使用场景**:
- **形状分析**: 分析对象的凸性，计算凸包用于形状描述。形状特征提取、形状分析
- **缺陷检测**: 通过比较原轮廓和凸包检测凹陷、缺陷。工业检测、质量检测
- **凸性分析**: 判断对象是否为凸形状，计算凸性缺陷。形状分析、几何计算
- **几何计算**: 计算凸包用于几何计算、碰撞检测。计算几何、游戏开发
- **典型应用**: 缺陷检测、形状分析、计算几何

**代码示例**:
```cpp
std::vector<cv::Point> hull;
cv::convexHull(contour, hull);
```

---

### 7.7 边界矩形 (BoundingRect, MinAreaRect)

**函数**: `cv::boundingRect()`, `cv::minAreaRect()`

**原理**: 
- **boundingRect**: 计算轮廓的轴对齐边界矩形
- **minAreaRect**: 计算轮廓的最小旋转矩形

**作用**:
- 获取对象边界框
- 对象定位
- 尺寸测量

**使用场景**:
- **对象定位**: 获取对象的边界框，用于对象定位、ROI 提取。目标检测、对象定位
- **目标跟踪**: 跟踪目标的边界框，用于目标跟踪。视频跟踪、运动分析
- **尺寸测量**: 测量对象的宽度和高度。工业测量、质量检测
- **对象检测**: 检测到的对象用边界框表示。目标检测系统、物体识别
- **选择建议**:
  - **boundingRect**: 轴对齐矩形，计算快，适合大多数场景
  - **minAreaRect**: 旋转矩形，更精确，适合旋转对象
- **典型应用**: 目标检测、目标跟踪、尺寸测量

**代码示例**:
```cpp
cv::Rect rect = cv::boundingRect(contour);
cv::RotatedRect minRect = cv::minAreaRect(contour);
```

---

### 7.8 最小外接圆 (MinEnclosingCircle)

**函数**: `cv::minEnclosingCircle()`

**原理**: 
计算包含轮廓的最小圆，使用迭代算法找到最小半径的圆。

**作用**:
- 计算最小外接圆
- 圆形对象检测
- 形状分析

**使用场景**:
- **圆形检测**: 检测图像中的圆形对象。工业检测中的圆形零件检测、医学图像中的圆形结构
- **形状分析**: 分析对象的圆形度，判断对象是否接近圆形。形状特征提取
- **对象定位**: 定位圆形对象的中心和半径。圆形目标定位、圆形标记检测
- **典型应用**: 工业检测、医学图像分析、圆形目标检测

**代码示例**:
```cpp
cv::Point2f center;
float radius;
cv::minEnclosingCircle(contour, center, radius);
```

---

### 7.9 轮廓匹配 (MatchShapes)

**函数**: `cv::matchShapes()`

**原理**: 
使用 Hu 不变矩比较两个轮廓的形状相似度。Hu 矩是七个对平移、旋转和缩放不变的矩。

**作用**:
- 形状比较
- 形状识别
- 对象分类

**使用场景**:
- **形状识别**: 通过形状匹配识别对象。形状识别系统、对象分类
- **对象分类**: 根据形状相似度对对象进行分类。对象分类、模式识别
- **形状匹配**: 匹配不同图像中的相似形状。形状检索、形状匹配
- **模式识别**: 模式识别中的形状匹配。模式识别、图像识别
- **匹配方法**:
  - **CONTOURS_MATCH_I1**: 方法 1，基于 Hu 矩
  - **CONTOURS_MATCH_I2**: 方法 2，基于 Hu 矩
  - **CONTOURS_MATCH_I3**: 方法 3，基于 Hu 矩
- **典型应用**: 形状识别、对象分类、模式匹配

**代码示例**:
```cpp
double match = cv::matchShapes(contour1, contour2, cv::CONTOURS_MATCH_I1, 0);
```

---

### 7.10 矩 (Moments, HuMoments)

**函数**: `cv::moments()`, `cv::HuMoments()`

**原理**: 
- **Moments**: 计算图像或轮廓的几何矩和中心矩
- **HuMoments**: 计算七个 Hu 不变矩，对平移、旋转和缩放不变

**作用**:
- 形状特征提取
- 对象识别
- 形状分析

**使用场景**:
- **特征提取**: 提取形状的矩特征用于分类、识别。形状特征提取、对象识别
- **形状识别**: 使用 Hu 不变矩进行形状识别。形状识别系统、对象分类
- **对象分类**: 根据矩特征对对象进行分类。对象分类、模式识别
- **模式匹配**: 模式匹配中的形状匹配。模式识别、图像识别
- **Hu 矩特性**: 对平移、旋转、缩放不变，适合形状匹配
- **典型应用**: 形状识别、对象分类、模式匹配

**代码示例**:
```cpp
cv::Moments m = cv::moments(contour);
cv::Mat hu;
cv::HuMoments(m, hu);
```

---

## 8. 特征检测

### 8.1 Harris 角点检测

**函数**: `cv::cornerHarris()`

**原理**: 
Harris 角点检测基于图像局部自相关函数。对于图像窗口，计算其在不同方向移动时的灰度变化：
$$E(u,v) = \sum_{x,y} w(x,y)[I(x+u,y+v) - I(x,y)]^2$$

使用结构张量 $M$ 的特征值来判断角点：
$$M = \sum_{x,y} w(x,y) \begin{bmatrix} I_x^2 & I_x I_y \\ I_x I_y & I_y^2 \end{bmatrix}$$

**作用**:
- 检测角点
- 特征点提取
- 图像配准

**使用场景**:
- **特征点检测**: 检测图像中的角点作为特征点。图像配准、特征匹配
- **图像配准**: 通过角点匹配实现图像配准。图像拼接、多视角图像对齐
- **目标跟踪**: 跟踪角点实现目标跟踪。光流跟踪、特征点跟踪
- **3D 重建**: 从多视角图像重建 3D 模型。计算机视觉、SLAM
- **参数选择建议**:
  - blockSize: 邻域大小，通常为 2
  - ksize: Sobel 核大小，通常为 3
  - k: Harris 参数，通常为 0.04-0.06
- **典型应用**: 图像配准、SLAM、3D 重建

**代码示例**:
```cpp
cv::Mat src, dst, dst_norm;
cv::cornerHarris(src, dst, 2, 3, 0.04);
cv::normalize(dst, dst_norm, 0, 255, cv::NORM_MINMAX, CV_8UC1);
```

---

### 8.2 Shi-Tomasi 角点检测 (GoodFeaturesToTrack)

**函数**: `cv::goodFeaturesToTrack()`

**原理**: 
Shi-Tomasi 是 Harris 的改进，使用结构张量的最小特征值来判断角点质量。只有当最小特征值大于阈值时，才认为是好的角点。

**作用**:
- 检测高质量角点
- 特征点提取
- 跟踪点选择

**使用场景**:
- **特征点检测**: 检测高质量角点用于特征匹配。比 Harris 更适合跟踪应用
- **光流跟踪**: 选择好的跟踪点进行光流跟踪。Lucas-Kanade 光流、特征点跟踪
- **图像配准**: 通过高质量角点实现图像配准。图像拼接、多视角对齐
- **SLAM**: 同时定位与建图中的特征点检测。视觉 SLAM、机器人导航
- **参数选择建议**:
  - maxCorners: 最大角点数量
  - qualityLevel: 角点质量阈值，0.01-0.1
  - minDistance: 角点间最小距离
- **典型应用**: 光流跟踪、SLAM、图像配准

**代码示例**:
```cpp
std::vector<cv::Point2f> corners;
cv::goodFeaturesToTrack(src, corners, 100, 0.01, 10);
```

---

### 8.3 亚像素角点 (CornerSubPix)

**函数**: `cv::cornerSubPix()`

**原理**: 
亚像素角点检测通过迭代优化将角点位置精确到亚像素级别。使用二次函数拟合角点邻域，找到精确的角点位置。

**作用**:
- 提高角点定位精度
- 亚像素级特征点
- 精确测量

**使用场景**:
- **高精度测量**: 需要亚像素级精度的测量应用。精密测量、质量检测
- **相机标定**: 相机标定中需要精确的角点位置。相机标定、立体视觉
- **精确配准**: 高精度图像配准应用。医学图像配准、精密测量
- **精密跟踪**: 需要高精度的特征点跟踪。精密跟踪、高精度测量
- **参数选择建议**:
  - winSize: 搜索窗口大小，通常为 (5,5) 或 (11,11)
  - zeroZone: 死区大小，通常为 (-1,-1)
  - criteria: 迭代终止条件，通常为 40 次迭代或 0.001 精度
- **典型应用**: 相机标定、精密测量、高精度配准

**代码示例**:
```cpp
std::vector<cv::Point2f> corners;
cv::Size winSize(5, 5);
cv::Size zeroZone(-1, -1);
cv::TermCriteria criteria(cv::TermCriteria::EPS + cv::TermCriteria::MAX_ITER, 40, 0.001);
cv::cornerSubPix(src, corners, winSize, zeroZone, criteria);
```

---

## 9. 图像分割

### 9.1 分水岭算法 (Watershed)

**函数**: `cv::watershed()`

**原理**: 
分水岭算法将图像看作地形图，灰度值代表高度。从标记点开始，模拟水从低处向高处填充的过程，当不同标记的水域相遇时，形成分水岭（边界）。

**作用**:
- 图像分割
- 分离接触的对象
- 区域分割

**使用场景**:
- **医学图像分割**: 分割医学图像中的不同组织、器官。CT、MRI 图像分析
- **细胞分割**: 分离接触的细胞，实现细胞计数。生物图像分析、细胞计数
- **对象分离**: 分离接触或重叠的对象。颗粒分析、对象计数
- **区域分割**: 将图像分割为不同区域。图像分割、区域分析
- **工作原理**: 需要先提供标记（markers），算法根据标记进行分割
- **典型流程**: 预处理 → 标记生成 → 分水岭分割 → 后处理
- **典型应用**: 医学图像分割、细胞计数、对象分离

**代码示例**:
```cpp
cv::Mat markers;
cv::watershed(image, markers);
```

---

### 9.2 GrabCut 分割

**函数**: `cv::grabCut()`

**原理**: 
GrabCut 是基于图割的交互式分割算法。它使用高斯混合模型（GMM）对前景和背景建模，通过迭代优化能量函数来分割图像。

**作用**:
- 交互式图像分割
- 前景提取
- 精确分割

**使用场景**:
- **前景提取**: 从图像中提取前景对象。图像抠图、背景替换
- **图像抠图**: 精确提取对象用于合成、编辑。图像编辑、广告设计
- **对象分割**: 交互式分割图像中的对象。图像编辑工具、交互式分割
- **交互式编辑**: 图像编辑软件中的智能选择工具。Photoshop 类似功能
- **初始化方式**:
  - **GC_INIT_WITH_RECT**: 用矩形初始化，适合快速分割
  - **GC_INIT_WITH_MASK**: 用掩码初始化，适合精确分割
- **典型应用**: 图像抠图工具、交互式分割、前景提取

**代码示例**:
```cpp
cv::Mat mask, bgdModel, fgdModel;
cv::Rect rect(50, 50, 450, 290);
cv::grabCut(image, mask, rect, bgdModel, fgdModel, 5, cv::GC_INIT_WITH_RECT);
```

---

### 9.3 均值漂移滤波 (PyrMeanShiftFiltering)

**函数**: `cv::pyrMeanShiftFiltering()`

**原理**: 
均值漂移是一种非参数密度估计算法。对于每个像素，在特征空间（颜色+位置）中迭代地移动到局部密度最大的位置，实现颜色聚类和空间平滑。

**作用**:
- 颜色聚类
- 图像平滑
- 分割预处理

**使用场景**:
- **颜色分割**: 基于颜色的图像分割，将相似颜色的区域合并。颜色分割、区域分割
- **图像平滑**: 平滑图像同时保持边缘，类似双边滤波但基于颜色聚类。图像平滑、降噪
- **预处理**: 作为更复杂分割算法的预处理步骤。分割预处理、颜色量化
- **颜色量化**: 减少图像颜色数量，实现颜色量化。图像压缩、颜色简化
- **参数选择建议**:
  - sp: 空间窗口半径，通常为 10-30
  - sr: 颜色窗口半径，通常为 20-60
- **典型应用**: 颜色分割、图像平滑、颜色量化

**代码示例**:
```cpp
cv::Mat dst;
cv::pyrMeanShiftFiltering(src, dst, 21, 51);
```

---

### 9.4 连通组件 (ConnectedComponents)

**函数**: `cv::connectedComponents()`, `cv::connectedComponentsWithStats()`

**原理**: 
连通组件标记算法（如两遍扫描算法）在二值图像中标记所有连通的区域。每个连通区域被赋予唯一的标签。

**作用**:
- 标记连通区域
- 对象计数
- 区域分析

**使用场景**:
- **对象计数**: 统计图像中的对象数量。细胞计数、颗粒计数、对象统计
- **区域标记**: 为每个连通区域分配唯一标签。区域标记、对象标记
- **图像分析**: 分析图像中的连通区域特性。图像分析、区域分析
- **目标检测**: 检测和标记图像中的目标对象。目标检测、对象定位
- **算法选择**:
  - **CCL_DEFAULT**: 默认算法，自动选择
  - **CCL_WU/CCL_SAUF**: SAUF 算法，快速
  - **CCL_GRANA/CCL_BBDT**: BBDT 算法
  - **CCL_BOLELLI/CCL_SPAGHETTI**: Spaghetti 算法，最新最快
- **WithStats 版本**: 提供区域统计信息（面积、边界框、质心等）
- **典型应用**: 细胞计数、颗粒分析、对象统计

**代码示例**:
```cpp
cv::Mat labels, stats, centroids;
int num_labels = cv::connectedComponentsWithStats(binary, labels, stats, centroids);
```

---

### 9.5 漫水填充 (FloodFill)

**函数**: `cv::floodFill()`

**原理**: 
漫水填充从种子点开始，递归地填充所有与种子点连通且满足条件的像素。类似于图像编辑软件中的"油漆桶"工具。

**作用**:
- 区域填充
- 连通区域标记
- 图像分割

**使用场景**:
- **区域填充**: 填充图像中的封闭区域。图像编辑、区域填充
- **图像编辑**: 图像编辑软件中的填充工具。类似 Photoshop 的油漆桶工具
- **分割辅助**: 作为图像分割的辅助工具，填充特定区域。交互式分割
- **区域选择**: 通过种子点选择连通区域。区域选择、ROI 提取
- **填充模式**:
  - **4 连通**: 上下左右 4 个方向
  - **8 连通**: 包括对角线方向
- **典型应用**: 图像编辑工具、区域填充、交互式分割

**代码示例**:
```cpp
cv::Point seedPoint(100, 100);
cv::Scalar newVal(255, 0, 0);
cv::Rect rect;
cv::floodFill(image, mask, seedPoint, newVal, &rect, cv::Scalar(), cv::Scalar(), 4);
```

---

## 10. 颜色空间转换

### 10.1 颜色空间转换 (CvtColor)

**函数**: `cv::cvtColor()`

**原理**: 
颜色空间转换通过数学变换将图像从一个颜色空间转换到另一个。OpenCV 支持多种颜色空间转换，如 BGR↔RGB、BGR↔HSV、BGR↔LAB 等。

**作用**:
- 颜色空间转换
- 颜色分析
- 图像处理预处理

**使用场景**:
- **颜色分析**: 转换到合适的颜色空间进行颜色分析。HSV 用于颜色分割、LAB 用于颜色距离计算
- **图像处理**: 不同颜色空间适合不同的图像处理任务。颜色校正、颜色增强
- **目标检测**: 转换颜色空间提高检测效果。HSV 用于颜色目标检测、YUV 用于视频处理
- **图像增强**: 在特定颜色空间进行增强后转换回原空间。颜色增强、对比度增强
- **常用转换**:
  - **BGR2GRAY**: 灰度化，大多数图像处理的第一步
  - **BGR2HSV**: 转换到 HSV 进行颜色分割、颜色分析
  - **BGR2LAB**: 转换到 LAB 进行颜色距离计算、颜色校正
  - **BGR2YUV**: 视频处理、亮度-色度分离
- **典型应用**: 颜色分割、颜色分析、目标检测、图像增强

**代码示例**:
```cpp
cv::Mat hsv;
cv::cvtColor(bgr, hsv, cv::COLOR_BGR2HSV);
```

---

### 10.2 常用颜色空间

#### BGR/RGB
- **用途**: 标准颜色表示
- **特点**: 三个通道分别表示蓝、绿、红

#### HSV/HSL
- **用途**: 颜色分割、颜色分析
- **特点**: 
  - H (Hue): 色调
  - S (Saturation): 饱和度
  - V (Value): 明度

#### LAB
- **用途**: 颜色距离计算、颜色分析
- **特点**: 感知均匀的颜色空间

#### YUV/YCrCb
- **用途**: 视频编码、颜色分析
- **特点**: 亮度-色度分离

#### GRAY
- **用途**: 灰度图像处理
- **特点**: 单通道灰度图像

---

## 11. 模板匹配

### 11.1 模板匹配 (MatchTemplate)

**函数**: `cv::matchTemplate()`

**原理**: 
模板匹配在图像中搜索与模板图像最相似的区域。使用滑动窗口方法，计算模板与图像每个位置的相似度。支持多种匹配方法：
- **TM_SQDIFF**: 平方差
- **TM_SQDIFF_NORMED**: 归一化平方差
- **TM_CCORR**: 相关
- **TM_CCORR_NORMED**: 归一化相关
- **TM_CCOEFF**: 相关系数
- **TM_CCOEFF_NORMED**: 归一化相关系数

**作用**:
- 在图像中查找模板
- 目标定位
- 模式匹配

**使用场景**:
- **目标检测**: 在图像中检测特定目标。工业检测、质量检测、目标定位
- **模式识别**: 识别图像中的特定模式。模式识别、特征匹配
- **图像搜索**: 在图像中搜索特定内容。图像检索、内容搜索
- **质量检测**: 检测产品中的缺陷、标记等。工业质量检测、缺陷检测
- **匹配方法选择**:
  - **TM_SQDIFF/TM_SQDIFF_NORMED**: 平方差，值越小越匹配
  - **TM_CCORR/TM_CCORR_NORMED**: 相关，值越大越匹配
  - **TM_CCOEFF/TM_CCOEFF_NORMED**: 相关系数，值越大越匹配（推荐）
- **注意事项**: 对尺度和旋转敏感，需要预处理或使用多尺度匹配
- **典型应用**: 工业检测、质量检测、目标定位

**代码示例**:
```cpp
cv::Mat result;
cv::matchTemplate(image, templ, result, cv::TM_CCOEFF_NORMED);
cv::Point minLoc, maxLoc;
double minVal, maxVal;
cv::minMaxLoc(result, &minVal, &maxVal, &minLoc, &maxLoc);
```

---

## 12. 霍夫变换

### 12.1 霍夫直线检测 (HoughLines)

**函数**: `cv::HoughLines()`, `cv::HoughLinesP()`

**原理**: 
霍夫变换将图像空间中的直线映射到参数空间（ρ-θ 空间）。在参数空间中，同一条直线上的点会形成峰值，通过检测峰值来检测直线。

标准霍夫变换: $ρ = x\cosθ + y\sinθ$

**作用**:
- 检测直线
- 线段检测
- 几何形状检测

**使用场景**:
- **直线检测**: 检测图像中的直线。文档分析、几何形状检测
- **车道线检测**: 自动驾驶中的车道线检测。ADAS、自动驾驶系统
- **文档分析**: 文档图像中的表格线、文字行检测。OCR、文档理解
- **几何分析**: 分析图像中的几何结构。建筑图像分析、工程图纸分析
- **参数选择建议**:
  - rho: 距离分辨率，通常为 1 像素
  - theta: 角度分辨率，通常为 π/180 弧度
  - threshold: 累加器阈值，取决于图像大小和直线数量
- **典型应用**: 车道线检测、文档分析、几何形状检测

**代码示例**:
```cpp
std::vector<cv::Vec2f> lines;
cv::HoughLines(edges, lines, 1, CV_PI/180, 150);
```

---

### 12.2 概率霍夫直线检测 (HoughLinesP)

**函数**: `cv::HoughLinesP()`

**原理**: 
概率霍夫变换是标准霍夫变换的改进，使用随机采样和线段验证，只返回线段的端点，效率更高。

**作用**:
- 检测线段
- 快速直线检测
- 线段端点定位

**使用场景**:
- **线段检测**: 检测线段并返回端点，比标准霍夫变换更实用。线段检测、端点定位
- **实时应用**: 实时应用中的直线检测，速度更快。实时视频处理、实时检测
- **几何分析**: 分析图像中的线段结构。几何分析、结构检测
- **参数选择建议**:
  - minLineLength: 最小线段长度
  - maxLineGap: 线段间最大间隙
- **优势**: 直接返回线段端点，比标准霍夫变换更实用
- **典型应用**: 实时车道线检测、线段检测、实时应用

**代码示例**:
```cpp
std::vector<cv::Vec4i> lines;
cv::HoughLinesP(edges, lines, 1, CV_PI/180, 50, 50, 10);
```

---

### 12.3 霍夫圆检测 (HoughCircles)

**函数**: `cv::HoughCircles()`

**原理**: 
霍夫圆检测在三维参数空间 (x, y, r) 中检测圆形。使用梯度信息来减少计算量，通过累加器检测圆心和半径。

**作用**:
- 检测圆形
- 圆形对象定位
- 几何形状检测

**使用场景**:
- **圆形检测**: 检测图像中的圆形对象。工业检测、圆形目标检测
- **工业检测**: 检测工业产品中的圆形零件、孔洞等。质量检测、零件检测
- **医学图像分析**: 检测医学图像中的圆形结构。细胞检测、血管检测
- **目标识别**: 识别圆形目标，如硬币、按钮等。目标识别、物体检测
- **参数选择建议**:
  - dp: 累加器分辨率，通常为 1
  - minDist: 圆心间最小距离
  - param1: 边缘检测的高阈值
  - param2: 累加器阈值，值越小检测越多
  - minRadius/maxRadius: 圆的半径范围
- **典型应用**: 工业检测、圆形目标检测、医学图像分析

**代码示例**:
```cpp
std::vector<cv::Vec3f> circles;
cv::HoughCircles(gray, circles, cv::HOUGH_GRADIENT, 1, gray.rows/8, 200, 100);
```

---

## 13. 距离变换

### 13.1 距离变换 (DistanceTransform)

**函数**: `cv::distanceTransform()`

**原理**: 
距离变换计算二值图像中每个像素到最近背景像素的距离。支持多种距离度量：
- **DIST_L1**: 曼哈顿距离
- **DIST_L2**: 欧氏距离
- **DIST_C**: 切比雪夫距离

**作用**:
- 计算距离图
- 骨架提取
- 形状分析
- 区域中心查找

**使用场景**:
- **骨架提取**: 提取对象的骨架（中轴线）。形状分析、字符识别
- **形状分析**: 分析对象的形状特性，如宽度分布等。形状分析、特征提取
- **区域中心定位**: 定位区域的中心点。对象定位、质心计算
- **图像处理**: 作为其他图像处理算法的中间步骤。形态学处理、形状分析
- **距离类型选择**:
  - **DIST_L1**: 曼哈顿距离，计算快
  - **DIST_L2**: 欧氏距离，最常用
  - **DIST_C**: 切比雪夫距离
- **典型应用**: 骨架提取、形状分析、区域中心定位

**代码示例**:
```cpp
cv::Mat dist;
cv::distanceTransform(binary, dist, cv::DIST_L2, 5);
```

---

## 14. 图像金字塔

### 14.1 图像金字塔 (PyrDown, PyrUp)

**函数**: `cv::pyrDown()`, `cv::pyrUp()`, `cv::buildPyramid()`

**原理**: 
图像金字塔是多分辨率表示方法。通过重复进行高斯平滑和下采样构建金字塔，每一层分辨率是上一层的一半。

**作用**:
- 多尺度图像表示
- 图像缩放
- 特征检测
- 图像融合

**使用场景**:
- **多尺度特征检测**: 在不同尺度检测特征，提高检测鲁棒性。SIFT、SURF 等多尺度特征检测
- **图像融合**: 图像融合、图像合成。图像拼接、HDR 合成
- **图像缩放**: 快速图像缩放，通过金字塔实现。图像缩放、多分辨率处理
- **目标检测**: 多尺度目标检测，在不同尺度检测目标。目标检测、物体识别
- **构建方法**:
  - **pyrDown**: 下采样，分辨率减半
  - **pyrUp**: 上采样，分辨率加倍
  - **buildPyramid**: 构建完整金字塔
- **典型应用**: 多尺度特征检测、图像融合、目标检测

**代码示例**:
```cpp
cv::Mat dst;
cv::pyrDown(src, dst);
cv::pyrUp(dst, dst);
```

---

## 算法选择指南

### 根据任务选择算法

| 任务 | 推荐算法 |
|------|---------|
| 去噪 | 高斯滤波、中值滤波、双边滤波 |
| 边缘检测 | Canny、Sobel、Laplacian |
| 图像增强 | 直方图均衡化、CLAHE |
| 二值化 | 固定阈值、Otsu、自适应阈值 |
| 轮廓提取 | findContours + Canny |
| 形状识别 | 轮廓匹配、Hu 矩 |
| 特征点检测 | Harris、Shi-Tomasi、SIFT、ORB |
| 图像分割 | 分水岭、GrabCut、连通组件 |
| 直线检测 | 霍夫变换 |
| 模板匹配 | matchTemplate |

### 性能考虑

- **实时应用**: 优先选择快速算法（如中值滤波、简单阈值）
- **高精度应用**: 使用精确算法（如 Canny、亚像素角点）
- **内存受限**: 避免构建大型数据结构（如完整图像金字塔）

---

## 总结

OpenCV 4.13.0 提供了丰富的图像处理算法，涵盖了从基础滤波到高级分割的各个方面。选择合适的算法需要考虑：

1. **任务需求**: 明确要解决的具体问题
2. **图像特性**: 考虑图像类型、噪声水平、对比度等
3. **性能要求**: 平衡精度和速度
4. **计算资源**: 考虑内存和计算能力限制

通过合理组合这些算法，可以构建强大的图像处理和分析系统。

---

*文档生成时间: 2024*  
*OpenCV 版本: 4.13.0*
